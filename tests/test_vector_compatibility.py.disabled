#!/usr/bin/env python3
"""
Test compatibility of new vector database architecture with existing KATO vector functionality.

This test suite ensures that the new vector database implementation is fully backward
compatible with existing KATO vector tests and functionality.
"""

import pytest
import sys
import os
import numpy as np
import time
import json
from pathlib import Path

# Add parent directory to path
sys.path.insert(0, str(Path(__file__).parent.parent))

# Import KATO modules
from kato.representations.vector_object import VectorObject
from kato.searches.vector_search_engine import CVCSearcherModern as CVCSearcher
from kato.config.vectordb_config import VectorDBConfig, EXAMPLE_CONFIGS
from kato.searches.vector_search_engine import VectorSearchEngine, CVCSearcherModern
from kato.storage import get_vector_store

# Import test fixtures
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '.')))
from fixtures.kato_fixtures import kato_fixture

# Helper function for backward compatibility
def calculate_diff_lengths(data):
    """
    Calculate the length of the differences between current and all known vectors.
    
    Args:
        data: Tuple of (state, vec) where state and vec are vectors
    
    Returns:
        List containing [vec, norm(state - vec)]
    """
    state, vec = data
    from numpy.linalg import norm
    return [vec, norm(state.vector - vec.vector)]


class TestVectorBackwardCompatibility:
    """Test backward compatibility with existing vector functionality"""
    
    def test_vector_object_creation(self):
        """Test VectorObject creation and properties"""
        # Create a simple vector
        vector_data = np.array([1.0, 2.0, 3.0, 4.0])
        vec_obj = VectorObject(vector_data)
        
        assert vec_obj.vector is not None
        assert vec_obj.name.startswith("VECTOR|")
        assert vec_obj.vector_hash is not None
        assert vec_obj.vector_length > 0
        
        # Test vector length calculation
        expected_length = np.sqrt(np.dot(vector_data, vector_data))
        assert np.isclose(vec_obj.vector_length, expected_length)
    
    def test_vector_object_operations(self):
        """Test VectorObject arithmetic operations"""
        vec1 = VectorObject(np.array([1, 2, 3]))
        vec2 = VectorObject(np.array([4, 5, 6]))
        
        # Addition
        vec_sum = vec1 + vec2
        assert isinstance(vec_sum, VectorObject)
        assert np.allclose(vec_sum.vector, np.array([5, 7, 9]))
        
        # Subtraction
        vec_diff = vec2 - vec1
        assert isinstance(vec_diff, VectorObject)
        assert np.allclose(vec_diff.vector, np.array([3, 3, 3]))
        
        # Multiplication
        vec_mul = vec1 * 2
        assert isinstance(vec_mul, VectorObject)
        assert np.allclose(vec_mul.vector, np.array([2, 4, 6]))
    
    def test_vector_object_comparison(self):
        """Test VectorObject comparison operations"""
        vec1 = VectorObject(np.array([1, 2, 3]))
        vec2 = VectorObject(np.array([1, 2, 3]))
        vec3 = VectorObject(np.array([4, 5, 6]))
        
        # Equality
        assert vec1 == vec2
        assert vec1 != vec3
        
        # Less than (based on vector length)
        short_vec = VectorObject(np.array([1, 0, 0]))
        long_vec = VectorObject(np.array([10, 10, 10]))
        assert short_vec < long_vec
    
    def test_cvc_searcher_legacy(self):
        """Test legacy CVCSearcher functionality"""
        # Create searcher
        searcher = CVCSearcher(procs=1)
        
        # Create test vectors
        vectors = {}
        for i in range(10):
            vec = VectorObject(np.random.rand(5))
            vectors[vec.name] = vec
        
        # Load vectors into RAM
        searcher.loadMemoryIntoRAM(vectors)
        assert len(searcher.datasubset) == 10
        
        # Test nearest neighbor search
        query = VectorObject(np.random.rand(5))
        nearest = searcher.findNearestPoints(query)
        
        # Should return 3 nearest neighbors
        assert isinstance(nearest, list)
        assert len(nearest) <= 3
        
        # Clear memory
        searcher.clearModelsFromRAM()
        assert len(searcher.datasubset) == 0
    
    def test_cvc_searcher_modern(self):
        """Test modern CVCSearcherModern functionality"""
        # Create modern searcher
        searcher = CVCSearcherModern(procs=4)
        
        # Create test vectors
        vectors = {}
        for i in range(10):
            vec = VectorObject(np.random.rand(5))
            vectors[vec.name] = vec
        
        # Load vectors (this should use the modern vector engine)
        searcher.loadMemoryIntoRAM(vectors)
        
        # Test nearest neighbor search
        query = VectorObject(np.random.rand(5))
        nearest = searcher.findNearestPoints(query)
        
        # Should return vector IDs
        assert isinstance(nearest, list)
        assert len(nearest) <= 3
        
        # Clear memory
        searcher.clearModelsFromRAM()
    
    def test_calculate_diff_lengths(self):
        """Test the calculate_diff_lengths function"""
        vec1 = VectorObject(np.array([1, 0, 0]))
        vec2 = VectorObject(np.array([0, 1, 0]))
        
        # Calculate difference
        result = calculate_diff_lengths((vec1, vec2))
        
        assert len(result) == 2
        assert result[0] == vec2  # The second vector
        assert isinstance(result[1], float)  # The distance
        
        # Distance should be sqrt(2) for orthogonal unit vectors
        expected_distance = np.sqrt(2)
        assert np.isclose(result[1], expected_distance, rtol=1e-5)


class TestVectorIntegrationWithKATO:
    """Test vector functionality integrated with KATO system"""
    
    @pytest.fixture(autouse=True)
    def setup_kato(self, kato_fixture):
        """Setup KATO for each test"""
        # Clear memory before each test
        kato_fixture.clear_all_memory()
        yield kato_fixture
        # Cleanup after test
        kato_fixture.clear_all_memory()
    
    def test_observe_vectors(self, kato_fixture):
        """Test observing vectors through KATO API"""
        # Create test vectors
        vectors = [
            [1.0, 2.0, 3.0],
            [4.0, 5.0, 6.0]
        ]
        
        # Observe vectors
        result = kato_fixture.observe({
            'strings': [],
            'vectors': vectors,
            'emotives': {}
        })
        
        assert result['status'] == 'observed'
        assert 'auto_learned_model' in result
    
    def test_vector_learning(self, kato_fixture):
        """Test learning sequences with vectors"""
        # Create a sequence with vectors
        sequence = [
            {'strings': ['start'], 'vectors': [[1, 0, 0]], 'emotives': {}},
            {'strings': ['middle'], 'vectors': [[0, 1, 0]], 'emotives': {}},
            {'strings': ['end'], 'vectors': [[0, 0, 1]], 'emotives': {}}
        ]
        
        # Observe the sequence
        for obs in sequence:
            result = kato_fixture.observe(obs)
            assert result['status'] == 'observed'
        
        # Learn the model
        model_name = kato_fixture.learn()
        assert model_name is not None
        
        # The model should be created
        models = kato_fixture.get_models()
        assert model_name in models
    
    def test_vector_predictions(self, kato_fixture):
        """Test predictions with vector data"""
        # Learn a simple sequence with vectors
        sequence = [
            {'strings': ['a'], 'vectors': [[1, 0]], 'emotives': {}},
            {'strings': ['b'], 'vectors': [[0, 1]], 'emotives': {}},
            {'strings': ['c'], 'vectors': [[1, 1]], 'emotives': {}}
        ]
        
        # Observe and learn
        for obs in sequence:
            kato_fixture.observe(obs)
        
        model_name = kato_fixture.learn()
        assert model_name is not None
        
        # Clear working memory and observe first element
        kato_fixture.clear_working_memory()
        kato_fixture.observe({'strings': ['a'], 'vectors': [[1, 0]], 'emotives': {}})
        
        # Get predictions
        predictions = kato_fixture.get_predictions()
        
        # Should have predictions
        assert len(predictions) > 0
        
        # Check prediction structure
        for pred in predictions:
            assert 'symbols' in pred
            assert 'recall' in pred
            assert 'emotives' in pred
            assert isinstance(pred['symbols'], list)
    
    def test_mixed_modality(self, kato_fixture):
        """Test mixed strings and vectors"""
        # Observe mixed modalities
        result = kato_fixture.observe({
            'strings': ['hello', 'world'],
            'vectors': [[0.5, 0.5, 0.5], [1.0, 0.0, 1.0]],
            'emotives': {'confidence': 0.8}
        })
        
        assert result['status'] == 'observed'
        
        # Check working memory
        wm = kato_fixture.get_working_memory()
        assert len(wm) >= 1
        
        # Should contain at least the string symbols
        first_event = wm[0]
        assert 'hello' in first_event or 'world' in first_event


class TestVectorDatabaseIntegration:
    """Test the new vector database integration"""
    
    def test_vector_search_engine_basic(self):
        """Test basic vector search engine functionality"""
        # Create engine with Qdrant backend
        config = VectorDBConfig(
            backend="qdrant",
            vector_dim=128,
            cache={"enabled": False}
        )
        
        engine = VectorSearchEngine(
            config=config,
            collection_name="test_vectors",
            enable_cache=False
        )
        
        # Test vector operations
        test_vector = np.random.rand(128)
        vector_id = "test_vec_1"
        
        # Note: Actual operations would require running services
        # This just tests the interface
        assert engine.collection_name == "test_vectors"
        assert engine.config.backend == "qdrant"
    
    def test_vector_store_factory(self):
        """Test vector store factory pattern"""
        from kato.storage import VectorStoreFactory
        
        # List available backends
        backends = VectorStoreFactory.list_backends()
        assert "qdrant" in backends
        
        # Test configuration loading
        config = EXAMPLE_CONFIGS["development"]
        assert config.backend == "qdrant"
        assert config.cache.enabled == False
    
    def test_configuration_system(self):
        """Test vector database configuration system"""
        # Test default configuration
        config = VectorDBConfig()
        assert config.backend == "qdrant"
        assert config.validate()
        
        # Test configuration with qdrant backend
        config = VectorDBConfig(backend="qdrant")
        assert config.backend == "qdrant"
        assert config.validate()
        
        # Test invalid configuration
        config = VectorDBConfig()
        config.backend = "invalid_backend"
        assert not config.validate()
    
    def test_vector_object_compatibility(self):
        """Test VectorObject compatibility with new system"""
        # Create vector objects
        vec1 = VectorObject(np.array([1, 2, 3, 4, 5]))
        vec2 = VectorObject(np.array([5, 4, 3, 2, 1]))
        
        # Test that vector objects work as before
        assert vec1.name.startswith("VECTOR|")
        assert vec1.vector_hash is not None
        
        # Test operations still work
        vec_sum = vec1 + vec2
        assert np.allclose(vec_sum.vector, np.array([6, 6, 6, 6, 6]))
        
        # Test comparison
        assert vec1 != vec2
        assert vec1 < vec2  # Based on vector length


class TestPerformanceComparison:
    """Compare performance between old and new vector implementations"""
    
    def test_search_performance_comparison(self):
        """Compare search performance between legacy and modern implementations"""
        n_vectors = 100
        vector_dim = 64
        
        # Create test vectors
        vectors = {}
        for i in range(n_vectors):
            vec = VectorObject(np.random.rand(vector_dim))
            vectors[vec.name] = vec
        
        query = VectorObject(np.random.rand(vector_dim))
        
        # Test legacy CVCSearcher
        legacy_searcher = CVCSearcher(procs=1)
        legacy_searcher.loadMemoryIntoRAM(vectors)
        
        start_time = time.time()
        legacy_results = legacy_searcher.findNearestPoints(query)
        legacy_time = time.time() - start_time
        
        # Test modern CVCSearcherModern
        modern_searcher = CVCSearcherModern(procs=1)
        modern_searcher.loadMemoryIntoRAM(vectors)
        
        start_time = time.time()
        modern_results = modern_searcher.findNearestPoints(query)
        modern_time = time.time() - start_time
        
        # Both should return results
        assert len(legacy_results) <= 3
        assert len(modern_results) <= 3
        
        # Log performance comparison
        print(f"\nPerformance Comparison:")
        print(f"Legacy CVCSearcher: {legacy_time*1000:.2f}ms")
        print(f"Modern CVCSearcher: {modern_time*1000:.2f}ms")
        
        # Modern should not be significantly slower than legacy
        # Allow up to 5x slower for compatibility layer overhead
        assert modern_time < legacy_time * 5, "Modern implementation is too slow"
    
    def test_memory_usage(self):
        """Test memory usage of vector storage"""
        n_vectors = 50
        vector_dim = 32
        
        # Create searchers
        legacy = CVCSearcher(procs=1)
        modern = CVCSearcherModern(procs=1)
        
        # Create and load vectors
        vectors = {}
        for i in range(n_vectors):
            vec = VectorObject(np.random.rand(vector_dim))
            vectors[vec.name] = vec
        
        # Load into both
        legacy.loadMemoryIntoRAM(vectors)
        modern.loadMemoryIntoRAM(vectors)
        
        # Both should have loaded the vectors
        assert len(legacy.datasubset) == n_vectors
        assert len(modern.datasubset) == n_vectors
        
        # Clear and verify
        legacy.clearModelsFromRAM()
        modern.clearModelsFromRAM()
        
        assert len(legacy.datasubset) == 0
        assert len(modern.datasubset) == 0


if __name__ == "__main__":
    # Run the tests
    pytest.main([__file__, "-v", "-s"])